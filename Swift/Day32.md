# Swift 최적화

### 전체 모듈 최적화(Whole Module Optimizations)
- 컴파일러는 Swift 파일들을 개별적으로 컴파일 함
    - ex. 파일이 100개라면 100개의 작업 단위로 컴파일하는 것
- 각 파일 간의 연관 관계(의존성, 상속 등)를 계산해서 미리 고려할 지점들을 설정해 둠
    - ex. BaseViewController를 상속받은 ViewController들의 상속 관계를 미리 파악해 둠
- WMO는 프로그램을 단일 단위로 컴파일하여 더 많은 최적화를 가능하게 함
    - 컴파일 시간은 증가함
- 런타임 성능을 향상시키기 위해 Xcode에서 활성화 가능

![image](https://hackmd.io/_uploads/BJE9gixsa.png)


<br><br>

## 최적화 레벨
![image](https://hackmd.io/_uploads/Sy4TpcliT.png)
- Onone
    - Debug 모드의 기본 설정
    - 모든 디버깅 정보를 기록함
    - 최적화를 최소한으로 진행함
    - 성능은 상대적으로 좋지 않음
- O
    - Release 모드의 기본 설정
    - 디버깅 정보를 전혀 기록하지 않음
    - 성능 최적화에 집중함
    
- Osize
    - 디버깅 정보를 기록은 하지만 일부 손실이 있음


<br>

![image](https://hackmd.io/_uploads/BJ0PqPgia.png)

배포할 때 애플에서 기본적으로 Release 모드에서 최적화를 적용함

![image](https://hackmd.io/_uploads/rknyODes6.png)

<br><br>

## 메서드 디스패치

**Dynamic Dispatch(Indirect Call)**
- 런타임에 호출할 함수 결정
- 참조 타입인 클래스(non-final)에서 발생함
    - 인스턴스의 특정 메서드를 호출할 때, 어느 상속 레벨에 있는 메서드가 호출되는지 컴파일러가 모르기 때문
    - 상속에 의해 발생하는 케이스기 때문에 구조체에서는 발생하지 않음
- 성능상 상대적으로 오버헤드가 발생함

<br>

**Static Dispatch(Direct Call)**
- 컴파일 타임에 호출할 함수 결정
- 값 타입인 구조체, 열거형에서 발생함
- 어느 함수를 호출해야하는지 런타임에 계산하지 않아도 되기 때문에 성능이 상대적으로 좋음

<br><br>

## 개발자가 관리할 수 있는 최적화

전반적으로 컴파일러에게 컴파일 시점에 연결 관계를 고려하지 않도록 명시적으로 설정해주는 방식으로 최적화가 적용됨

<br>

### 접근제어자 설정
- 객체 외부에서 사용하지 않는 프로퍼티, 메서드를 private으로 선언
    - 컴파일러는 사용 가능성이 있는 모든 멤버에 대해 연결 여부를 검사하기 때문에, private으로 선언해두면 다른 파일 혹은 객체에서 해당 멤버에 접근했는지 검사하지 않음
- 협업 관점에서도 함수의 사용 범위에 대해 커뮤니케이션 리소스를 확보할 수 있음
- 외부 모듈(라이브러리)를 사용하고 있다면 메인 타겟의 접근 제어를 internal 이하로 설정하는 것이 좋음

<br>

### final 사용
- 특정 클래스를 상속하지 않을 것임을 명시하는 것
- 컴파일러가 컴파일 시 해당 클래스의 함수가 다른 곳에서 재정의 되었는지를 검사하지 않아도 되기 때문에 성능이 향상됨
    - 런타임에 함수 호출 시 상속 관계 중 어느 함수를 호출하는지 VTable을 검사하는 시간이 생략되기 때문
