## 함수형 프로그래밍

1. input과 output이 존재함
    - 처리할 인자를 전달하고, 처리 결과를 반환받음
2. 외부 환경으로부터 독립적
    - 함수 밖에 있는 대상을 참조하거나 변경시키지 않음
3. 같은 input에 대해서 언제나 동일한 output을 생산
    - 2번의 특성으로 인한 효과
    - 전달받은 인자 외에 다른 것은 참조하지 않기 때문에 동일한 output을 반환함
    - 이러한 함수를 ‘순수 함수'라고 함
    - 비함수형 프로그래밍은 참조하는 외부 변수에 의해서 실행 결과가 변화할 수 있음
        - 변수가 변수라고 불리는 이유!
4. 외부 변수를 사용하더라도, 그 본체에 접근해서 값을 변경하지 않고 인자로 받아서 사본으로 작업하기 때문에 부작용으로부터 자유로움
5. 문제의 소지가 있는 작업은 하지 않는 작성 방식
6. 100% 함수형의 기준에 맞출수는 없지만, 일정한 작업 단위에 있어서는 준수하려고 노력하는 것

### 함수형 프로그래밍의 특징

1. 순수함수(Pure Function)
    - 동일한 input에는 항상 같은 output을 반환해야 함
        - 함수의 구현부만 봐도, 입력 값에 대한 결과를 예상할 수 있음!
    - 함수의 실행이 프로그램의 실행에 영향을 미치지 않아야 함
    - 함수 내부에서 인자의 값을 변경하거나 프로그램 상태를 변경하는 Side Effect가 없는 것
        
        ```swift
        let num = 1
        
        // 함수 내부에서 함수 외부의 전역 변수인 num을 참조하기 때문에 순수함수 X
        func add(a : Int) -> Int {
        	return a + num
        }
        
        // 함수가 프로그램 실행에 영향을 미치지 않고, 매개 변수로만 return을 결정하므로 순수함수 O
        func add(a : Int, b : Int) -> Int {
        	return a + b
        }
        ```
        
2. 비상태(Stateless), 불변성(Immutability)
    - 함수형 프로그래밍에서 데이터는 변하지 않는 불변성을 유지해야 함
    - 데이터의 변경이 필요하다면, 원본 데이터를 직접 변경하지 않음
        - 원본 데이터의 복사본을 생성하여 변경 → 변경한 복사본으로 작업을 진행
        
        ```swift
        // age 프로퍼티를 가진 Person 클래스의 인스턴스 person
        var person = Person(age : 25)
        
        // 전역으로 선언된 person 인스턴스의 age를 직접 변경하므로 불변성 X
        func increaseAge(person : Person) -> Person {
        	person.age += 1
        	return person
        }
        
        // 기존의 person.age를 참고하지만, 원본을 직접 변경하지 않고 새로운 인스턴스를 반환하므로 불변성 O
        func increaseAge(person : Person) -> Person {
        	return Person(age : person.age + 1)
        }
        ```
        
3. 선언형 함수 (Expressions)
    - 명령형은 ‘어떻게', 선언형은 ‘무엇을' 할 것인가에 집중
    - 함수형 프로그래밍에서는 if, switch, for와 같은 명령문을 배제하고 함수형 코드로 사용
    
    ```swift
    var numbers = [1,2,3]
    
    // for문을 사용하여 numbers에 각 원소에 특정 값을 곱해주는 명령형 프로그래밍
    func multiply(numbers : [Int], multiplier : Int) {
    	for i in 0..<numbers.count {
    		numbers[i] *= multiplier
    }
    
    // for문 대신 고차함수 map으로 대치. 각 원소에 특정 값을 곱한 새로운 배열을 반환
    func multiply(numbers : [Int], multiplier : Int) -> [Int] {
    	return numbers.map{$0 * multiplier}
    }
    ```
    
4. 1급 객체와 고차함수
    - 함수형 프로그래밍에서 함수는 1급 객체가 됨
    - 1급 객체가 되면 함수는 다음과 같은 특징을 가짐
        - 변수나 데이터 구조에 담을 수 있음
        - 파라미터로 전달할 수 있음
        - 반환값으로 사용될 수 있음
        - 할당에 사용된 이름과 관계없이 고유한 구별 가능
        - 동적으로 프로퍼티 할당 가능
    
    ```swift
    let numbers = [1,2,3]
    
    // 함수를 변수에 할당
    let addTwo : (Int) -> Int = { (x : Int) in
    	return x + 2
    }
    // 함수 결과로 함수를 반환
    let addTwoWithNumbers = numbers.map{addTwo($0)}
    
    print(addTwoWithNumbers) // [3,4,5]
    ```
    
5. 커링
    - 커링을 통해 여러 인자를 받는 함수를 단계적으로 처리할 수 있음
    - 인자 중 고정값과 비고정값을 분리하여 호출 시 지정할 수 있게 함
    - 커링은 다소 생소한 개념으로 하단의 포스트를 참고하여 추가적으로 정리## 함수형 프로그래밍

1. input과 output이 존재함
    - 처리할 인자를 전달하고, 처리 결과를 반환받음
2. 외부 환경으로부터 독립적
    - 함수 밖에 있는 대상을 참조하거나 변경시키지 않음
3. 같은 input에 대해서 언제나 동일한 output을 생산
    - 2번의 특성으로 인한 효과
    - 전달받은 인자 외에 다른 것은 참조하지 않기 때문에 동일한 output을 반환함
    - 이러한 함수를 ‘순수 함수'라고 함
    - 비함수형 프로그래밍은 참조하는 외부 변수에 의해서 실행 결과가 변화할 수 있음
        - 변수가 변수라고 불리는 이유!
4. 외부 변수를 사용하더라도, 그 본체에 접근해서 값을 변경하지 않고 인자로 받아서 사본으로 작업하기 때문에 부작용으로부터 자유로움
5. 문제의 소지가 있는 작업은 하지 않는 작성 방식
6. 100% 함수형의 기준에 맞출수는 없지만, 일정한 작업 단위에 있어서는 준수하려고 노력하는 것

### 함수형 프로그래밍의 특징

1. 순수함수(Pure Function)
    - 동일한 input에는 항상 같은 output을 반환해야 함
        - 함수의 구현부만 봐도, 입력 값에 대한 결과를 예상할 수 있음!
    - 함수의 실행이 프로그램의 실행에 영향을 미치지 않아야 함
    - 함수 내부에서 인자의 값을 변경하거나 프로그램 상태를 변경하는 Side Effect가 없는 것
        
        ```swift
        let num = 1
        
        // 함수 내부에서 함수 외부의 전역 변수인 num을 참조하기 때문에 순수함수 X
        func add(a : Int) -> Int {
        	return a + num
        }
        
        // 함수가 프로그램 실행에 영향을 미치지 않고, 매개 변수로만 return을 결정하므로 순수함수 O
        func add(a : Int, b : Int) -> Int {
        	return a + b
        }
        ```
        
2. 비상태(Stateless), 불변성(Immutability)
    - 함수형 프로그래밍에서 데이터는 변하지 않는 불변성을 유지해야 함
    - 데이터의 변경이 필요하다면, 원본 데이터를 직접 변경하지 않음
        - 원본 데이터의 복사본을 생성하여 변경 → 변경한 복사본으로 작업을 진행
        
        ```swift
        // age 프로퍼티를 가진 Person 클래스의 인스턴스 person
        var person = Person(age : 25)
        
        // 전역으로 선언된 person 인스턴스의 age를 직접 변경하므로 불변성 X
        func increaseAge(person : Person) -> Person {
        	person.age += 1
        	return person
        }
        
        // 기존의 person.age를 참고하지만, 원본을 직접 변경하지 않고 새로운 인스턴스를 반환하므로 불변성 O
        func increaseAge(person : Person) -> Person {
        	return Person(age : person.age + 1)
        }
        ```
        
3. 선언형 함수 (Expressions)
    - 명령형은 ‘어떻게', 선언형은 ‘무엇을' 할 것인가에 집중
    - 함수형 프로그래밍에서는 if, switch, for와 같은 명령문을 배제하고 함수형 코드로 사용
    
    ```swift
    var numbers = [1,2,3]
    
    // for문을 사용하여 numbers에 각 원소에 특정 값을 곱해주는 명령형 프로그래밍
    func multiply(numbers : [Int], multiplier : Int) {
    	for i in 0..<numbers.count {
    		numbers[i] *= multiplier
    }
    
    // for문 대신 고차함수 map으로 대치. 각 원소에 특정 값을 곱한 새로운 배열을 반환
    func multiply(numbers : [Int], multiplier : Int) -> [Int] {
    	return numbers.map{$0 * multiplier}
    }
    ```
    
4. 1급 객체와 고차함수
    - 함수형 프로그래밍에서 함수는 1급 객체가 됨
    - 1급 객체가 되면 함수는 다음과 같은 특징을 가짐
        - 변수나 데이터 구조에 담을 수 있음
        - 파라미터로 전달할 수 있음
        - 반환값으로 사용될 수 있음
        - 할당에 사용된 이름과 관계없이 고유한 구별 가능
        - 동적으로 프로퍼티 할당 가능
    
    ```swift
    let numbers = [1,2,3]
    
    // 함수를 변수에 할당
    let addTwo : (Int) -> Int = { (x : Int) in
    	return x + 2
    }
    // 함수 결과로 함수를 반환
    let addTwoWithNumbers = numbers.map{addTwo($0)}
    
    print(addTwoWithNumbers) // [3,4,5]
    ```
    
5. 커링
    - 커링을 통해 여러 인자를 받는 함수를 단계적으로 처리할 수 있음
    - 인자 중 고정값과 비고정값을 분리하여 호출 시 지정할 수 있게 함
    - 커링은 다소 생소한 개념으로 하단의 포스트를 참고하여 추가적으로 정리
