# 구조체

- 스위프트에서 대부분의 타입은 구조체로 이루어짐
- 구조체는 **값(Value) 타입**
- 타입 이름은 대문자 카멜케이스를 사용하여 정의
    - **K : 구조체로 만든 인스턴스A를 인스턴스B에 할당한 뒤, 인스턴스A 또는 B의 속성을 변경하여도 다른 인스턴스에는 영향을 주지 않음**

## 구조체 문법

- 구조체 정의 : `struct` 키워드 사용

```swift
struct 이름 {
	구현 내용
}
```

- 구조체 속성(Property) 및 메서드(Method) 구현

```swift
// 구조체 선언
struct Sample {
    var mutableProperty : Int = 0 // 가변 property(변수)
    let immutableProperty : Int = 0 // 불변 property(상수)
    
    // 복사한 인스턴스가 사용하는 property가 아닌, 타입 자체만 사용 가능한 property
    static var typeProperty : Int = 0 // 타입 property, static을 붙임
    static let typeImProperty : Int = 0 // 불변 type property
    
    func instanceMethod() {
        print("instance가 사용하는 method 입니다.")
    }

    static func typeMethod() {
        print("type에서만 사용 가능한 method 입니다.")
    }
}

// 인스턴스 생성 및 사용

// Sample 구조체의 mutableInstance라는 가변 instance 생성
// mutableInstance라는 가변 instance에 Sample 구조체를 할당
// var 변수명 : 구조체이름 = 구조체이름()
var mutableInstance : Sample = Sample()

// 구조체가 가지고 있는 속성과 메서드를 똑같이 가지고 있음
// instance명.property명으로 instance 내부에 있는 속성에 접근 및 할당할 수 있음
mutableInstance.mutableProperty = 100
mutableInstance.instanceMethod() // instance가 사용하는 method 입니다.

// 가변 instance지만 속성이 불변 property기 때문에 수정 불가
mutableInstance.immutableProperty = 100 // 컴파일 오류 발생

// Sample 구조체의 immutableInstance라는 불변 instance 생성
let immutableInstance : Sample = Sample()

// let으로 생성한 불변 instance이기 때문에 property의 가변 여부에 관계 없이 수정 불가
immutableInstance.mutableProperty = 100 // 컴파일 오류 발생
immutableInstance.immutableProperty = 100 // 컴파일 오류 발생

// instance가 아닌 구조체에만 사용 가능한 type property 및 method
Sample.typeProperty = 300
// type 안에서도 불변 property는 수정 불가
Sample.typeImProperty = 300
Sample.typeMethod() // type에서만 사용 가능한 method 입니다.

// instance에서는 static으로 선언된 type property나 method를 사용할 수 없음
mutableInstance.typeProperty = 300 // 컴파일 오류 발생
mutableInstance.typeMethod() // 컴파일 오류 발생
```

- 자기소개 구조체 만들기

```swift
struct Introduce {
    var name : String = "Undefined"
    var age : Int = 0
    var `class` : String = "A" // 기존에 존재하는 키워드를 이름으로 사용하고 싶을 때는 `이름`
    
// self를 사용하는 것과 사용하지 않는 것 모두 같음
    func selfIntroduce() {
        print("제 \(name)이고, 나이는 \(self.age) 입니다.")
    }
}

var kaz : Introduce = Introduce()

kaz.selfIntroduce() // 저는 A 반의 Undefined 이고, 나이는 0 입니다.

// instance의 각 속성에 값 할당
kaz.name = "Kaz"
kaz.age = 29
kaz.class = "B"

// 변경된 속성에 맞춰서 method 실행
kaz.selfIntroduce() // 저는 B 반의 Kaz 이고, 나이는 29 입니다.

```
